
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pybbfmm &#8212; pybbfmm 0.1 documentation</title>
    <link rel="stylesheet" href="_static/custom.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Concepts" href="concepts.html" />
    <!-- Monitoring pageviews is really useful to me to see what kind of stuff I've done is useful to everyone else.
    But I'm keen to not to track any more than that, and so this is a minimal, self-hosted solution. It records
    nothing more than'd be in the server logs. -->
    <script>
      url = "https://live.andyljones.com/mat/mat.php";
      xhr = new XMLHttpRequest();
      xhr.open("POST", url, true);
      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');

      params = 'idsite=1&rec=1'
      params += '&url=' + encodeURIComponent(window.location.href);
      params += '&urlref=' + encodeURIComponent(document.referrer);
      params += '&rand=' + Math.floor(16384*Math.random())
      xhr.send(params)
    </script>
    <noscript>
      <img src="https://live.andyljones.com/mat/mat.php?idsite=1&amp;rec=1" style="border:0" alt=""/>
    </noscript>

   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />


  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">pybbfmm</a></h1>



<p class="blurb">A GPU fast multipole method</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=andyljones&repo=pybbfmm&type=star&count=False&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="concepts.html">Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
      <li>Next: <a href="concepts.html" title="next chapter">Concepts</a></li>
  </ul></li>
</ul>
</div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="pybbfmm">
<h1>pybbfmm<a class="headerlink" href="#pybbfmm" title="Permalink to this headline">¶</a></h1>
<p>This is a (optionally!) GPU-accelerated black-box fast multipole method. On a RTX 2080, it evaluates a 10m-point
community transmission problem in 4s per timestep.</p>
<p>While optimized for 2D problems in the million-point-scale, the code supports problems with any number of dimensions,
with arbitrary kernels defined entirely in Python.</p>
<p>You can read an animated explanation of fast multipole methods <a class="reference external" href="https://andyljones.com/posts/multipole-methods.html">here</a>.</p>
<div class="section" id="demo">
<h2>Demo<a class="headerlink" href="#demo" title="Permalink to this headline">¶</a></h2>
<p><strong>This is just a tech demo, not an epidemiological model</strong></p>
<video controls src="_static/demo.mp4" autoplay loop muted type="video/mp4" width=640 height=640></video><p>This demonstrates the acceleration of a community transmission kernel. It simulates 10 million agents, the infected
of whom emit a cloud a few kilometres across. This cloud represents agents’ random interactions in their community.
At each step, the method evaluates all 100tn pairs of interactions to figure out who else is at risk of infection.
Each step takes about 4s. Extrapolating from smaller problems, the direct approach would take 4h on the same GPU, or
about a week on the CPU.</p>
<p><a class="reference external" href="pybbfmm/demo/__init__.py">Take a look at the code for the demo</a>, or try it out for yourself <a class="reference external" href="https://colab.research.google.com/drive/1Xsmru2czbfVpzGc1e5IW8BOgLmJXBUmN">in the cloud with
Google Colab</a>.</p>
</div>
<div class="section" id="setup">
<h2>Setup<a class="headerlink" href="#setup" title="Permalink to this headline">¶</a></h2>
<p>For just the solver,</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>pip install --upgrade git+https://github.com/andyljones/pybbfmm
</pre></div>
</div>
<p>For the solver and the demo code,</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>pip install --upgrade git+https://github.com/andyljones/pybbfmm#egg<span class="o">=</span>pybbfmm<span class="o">[</span>demo<span class="o">]</span>
</pre></div>
</div>
</div>
<div class="section" id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">aljpy</span> <span class="kn">import</span> <span class="n">arrdict</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">pybbfmm</span>

<span class="n">prob</span> <span class="o">=</span> <span class="n">arrdict</span><span class="o">.</span><span class="n">arrdict</span><span class="p">(</span>
    <span class="c1"># Specify the locations of the sources</span>
    <span class="n">sources</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]],</span>
    <span class="c1"># Specify the charges</span>
    <span class="n">charges</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span><span class="p">],</span>
    <span class="c1"># Specify the locations of the targets</span>
    <span class="n">targets</span><span class="o">=</span><span class="p">[[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]])</span>

<span class="c1"># Turn it into torch tensors</span>
<span class="n">prob</span> <span class="o">=</span> <span class="n">prob</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">)</span>

<span class="c1"># Optional: ship it to the GPU</span>
<span class="c1"># prob = prob.float().cuda()</span>

<span class="c1"># Define the kernel</span>
<span class="n">prob</span><span class="p">[</span><span class="s1">&#39;kernel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Solve!</span>
<span class="n">soln</span> <span class="o">=</span> <span class="n">pybbfmm</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>   <span class="c1"># tensor([0.5000])</span>
</pre></div>
</div>
</div>
<div class="section" id="notes">
<h2>Notes<a class="headerlink" href="#notes" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li><p>This represents a few weeks worth of work. There is a lot of performance still to wring out of the system. I think
memory efficiency could probably be upped 2x-4x, and time efficiency 10x with a month or so of effort.</p></li>
<li><p>The main limitation for large problems is memory. With accuracy turned all the way down to <cite>N=1</cite> Chebyshev node per
box, about 22m sources &amp; targets can be fit on the 10GB of a RTX 2080 GPU.</p></li>
<li><p>There are various ways to get improvements in that 22m number - like swapping to using ints instead of longs - but
the ultimate, scalable solution likely involves streaming parts of the tree to the GPU as needed.</p></li>
<li><p>While the code supports any number of dimensions, 3 and above dims will be <em>extremely</em> slow. The location of the
issue is obvious from profiling, but as 3D problems aren’t my priority right now I’ve left it be.</p></li>
<li><p>The code works just as well on the CPU, though slower. All that’s needed is to drop the <cite>.cuda()</cite> call when forming
your problem.</p></li>
<li><p>This is part of a larger project about writing a certain kind of epidemiological models as the sum of an n-body
problem, a sparse matrix multiplication, and a finite-state machine.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="background">
<h2>Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h2>
<p>This grew out of some exploratory work on replicating <a class="reference external" href="https://www.imperial.ac.uk/media/imperial-college/medicine/sph/ide/gida-fellowships/Imperial-College-COVID19-NPI-modelling-16-03-2020.pdf">Ferguson et al’s non-pharmaceutical intervention
report</a>.
I found that the slow part of the <a class="reference external" href="https://static-content.springer.com/esm/art%3A10.1038%2Fnature04795/MediaObjects/41586_2006_BFnature04795_MOESM28_ESM.pdf">underlying spatiotemporal
model</a>
was the community transmission step, where each contagious person radiates a cloud of infectiousness. This is in many
ways similar to how n-body simulations work, and yet I couldn’t find anything in the epidemiological literature about
accelerating community transmission calculations using fast multipole methods.</p>
<p>I suspect this is because fast multipole methods are fairly tricky to implement, and at least using the traditional
approach require a lot of careful analytical expansions. More recent research has introduced <a class="reference external" href="https://mc.stanford.edu/cgi-bin/images/f/fa/Darve_bbfmm_2009.pdf">black box fast
multipole methods</a> which let you accelerate
n-body-esque simulations while excusing you from doing any hard math.</p>
</div>
<div class="section" id="resources">
<h2>Resources<a class="headerlink" href="#resources" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference external" href="https://mc.stanford.edu/cgi-bin/images/f/fa/Darve_bbfmm_2009.pdf">William &amp; Fong’s original paper</a> on the
black-box fast multipole method is the best place to start.</p></li>
<li><p><a class="reference external" href="https://pdfs.semanticscholar.org/97f0/d2a31d818ede922c9a59dc17f710642332ca.pdf">Carrier, Greengard &amp; Rokhlin’s original paper</a> on the fast multipole method is
still the best resource on implementing dynamic trees. Their notation is used extensively in the <cite>orthantree</cite>
module.</p></li>
<li><p>I’ve <a class="reference external" href="https://andyljones.com/posts/multipole-methods.html">made an animated explanation of the fast multipole method</a> to go with this library.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="alternatives">
<h2>Alternatives<a class="headerlink" href="#alternatives" title="Permalink to this headline">¶</a></h2>
<p>There are a <a class="reference external" href="https://github.com/sivaramambikasaran/BBFMM2D">couple</a> of <a class="reference external" href="https://github.com/DrFahdSiddiqui/bbFMM2D-Python">Python</a> implementations <a class="reference external" href="https://github.com/ruoxi-wang/PBBFMM3D">around</a>, but none of them are easy to use or modify.</p>
</div>
<div class="section" id="citation">
<h2>Citation<a class="headerlink" href="#citation" title="Permalink to this headline">¶</a></h2>
<div class="highlight-bib notranslate"><div class="highlight"><pre><span></span><span class="nc">@software</span><span class="p">{</span><span class="nl">pybbfmm</span><span class="p">,</span>
<span class="na">author</span> <span class="p">=</span> <span class="s">{{Andy L Jones}}</span><span class="p">,</span>
<span class="na">title</span> <span class="p">=</span> <span class="s">{pybbfmm}</span><span class="p">,</span>
<span class="na">url</span> <span class="p">=</span> <span class="s">{https://www.github.com/andyljones/pybbfmm}</span><span class="p">,</span>
<span class="na">version</span> <span class="p">=</span> <span class="s">{0.0}</span><span class="p">,</span>
<span class="na">date</span> <span class="p">=</span> <span class="s">{2020-04-08}</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="index">
<h2>Index<a class="headerlink" href="#index" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="concepts.html">Concepts</a><ul>
<li class="toctree-l2"><a class="reference internal" href="concepts.html#arrdicts-and-dotdicts">arrdicts and dotdicts</a></li>
<li class="toctree-l2"><a class="reference internal" href="concepts.html#problems">Problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="concepts.html#presolve-trees-indices-schemes">Presolve: trees, indices &amp; schemes</a></li>
<li class="toctree-l2"><a class="reference internal" href="concepts.html#evaluate-weights-interactions-contributions">Evaluate: weights, interactions &amp; contributions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="reference.html#module-pybbfmm">pybbfmm</a></li>
<li class="toctree-l2"><a class="reference internal" href="reference.html#module-pybbfmm.chebyshev">chebyshev</a></li>
<li class="toctree-l2"><a class="reference internal" href="reference.html#module-pybbfmm.orthantree">orthantree</a></li>
<li class="toctree-l2"><a class="reference internal" href="reference.html#module-pybbfmm.ragged">ragged</a></li>
<li class="toctree-l2"><a class="reference internal" href="reference.html#module-pybbfmm.sets">sets</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2020, Andy L. Jones.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>